import { useCallback, useEffect, useMemo, useRef, useState } from 'react'
import { useAuth } from '@/components/common/auth-provider'
import { supabase } from '@/lib/supabase'
import type { Bookmark, BookmarkFilters } from '@/types/database'

export function useBookmarks(filters?: BookmarkFilters) {
  const { user } = useAuth()
  const [allBookmarks, setAllBookmarks] = useState<Bookmark[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  // „ÇØ„É©„Ç§„Ç¢„É≥„Éà„Çµ„Ç§„Éâ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
  const bookmarks = useMemo(() => {
    if (!allBookmarks) return []

    return allBookmarks.filter((bookmark) => {
      // „Çø„Ç∞„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
      if (filters?.tags) {
        const hasTag = bookmark.bookmark_tags?.some(
          (tagRelation) => tagRelation.tag_id === filters.tags,
        )
        if (!hasTag) return false
      }

      // „Çπ„ÉÜ„Éº„Çø„Çπ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
      if (filters?.status) {
        if (Array.isArray(filters.status)) {
          if (!filters.status.includes(bookmark.status)) return false
        } else {
          if (bookmark.status !== filters.status) return false
        }
      }

      // „ÅäÊ∞ó„Å´ÂÖ•„Çä„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
      if (filters?.is_favorite !== undefined) {
        if (bookmark.is_favorite !== filters.is_favorite) return false
      }

      // „Éî„É≥Áïô„ÇÅ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
      if (filters?.is_pinned !== undefined) {
        if (bookmark.is_pinned !== filters.is_pinned) return false
      }

      // Ê§úÁ¥¢„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
      if (filters?.search) {
        const searchTerm = filters.search.toLowerCase()
        const titleMatch = bookmark.title?.toLowerCase().includes(searchTerm)
        const descriptionMatch = bookmark.description
          ?.toLowerCase()
          .includes(searchTerm)
        const memoMatch = bookmark.memo?.toLowerCase().includes(searchTerm)

        if (!titleMatch && !descriptionMatch && !memoMatch) return false
      }

      return true
    })
  }, [allBookmarks, filters])

  // stale closureÂØæÁ≠ñÔºöÂ∏∏„Å´ÊúÄÊñ∞„ÅÆbookmarksÁä∂ÊÖã„Çíref„Åß‰øùÊåÅ
  const bookmarksRef = useRef(bookmarks)
  bookmarksRef.current = bookmarks

  // ÂÖ®„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØÂèñÂæóÈñ¢Êï∞
  const fetchAllBookmarks = useCallback(async () => {
    try {
      setLoading(true)
      const url = '/api/bookmarks'
      const response = await fetch(url)

      if (!response.ok) {
        throw new Error('„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü')
      }
      const result = await response.json()
      setAllBookmarks(result.data || [])
      setError(null)
    } catch (err) {
      console.error('Error fetching bookmarks:', err)
      setError(
        err instanceof Error ? err.message : '„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü',
      )
    } finally {
      setLoading(false)
    }
  }, [])

  // ÂàùÂõû„Éá„Éº„ÇøÂèñÂæó
  useEffect(() => {
    fetchAllBookmarks()
  }, [fetchAllBookmarks])

  // Supabase Realtime„Åß„É™„Ç¢„É´„Çø„Ç§„É†Êõ¥Êñ∞Ôºà„Éï„Ç£„É´„Çø„Éº„Å™„Åó„ÄÅ„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂÅ¥„ÅßÂá¶ÁêÜÔºâ
  useEffect(() => {
    if (!user) return

    let reconnectTimeoutId: NodeJS.Timeout | null = null
    let reconnectAttempts = 0
    const maxReconnectAttempts = 3
    let isUnmounted = false
    let currentChannel: any = null // ÁèæÂú®„ÅÆ„ÉÅ„É£„É≥„Éç„É´ÂèÇÁÖß„Çí‰øùÊåÅ

    const setupRealtime = (): (() => void) => {
      console.log(
        `üîß Setting up Realtime for user: ${user.id} (attempt ${reconnectAttempts + 1})`,
      )
      const channelName = `bookmarks-changes-${user.id}`
      console.log('üìª Creating channel:', channelName)

      // Êó¢Â≠ò„ÅÆ„ÉÅ„É£„É≥„Éç„É´„Åå„ÅÇ„Çå„Å∞„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
      if (currentChannel) {
        console.log('üßπ Cleaning up previous channel before setup')
        currentChannel.unsubscribe()
      }

      const channel = supabase.channel(channelName)

      // ÁèæÂú®„ÅÆ„ÉÅ„É£„É≥„Éç„É´ÂèÇÁÖß„ÇíÊõ¥Êñ∞
      currentChannel = channel
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'bookmarks',
            // RLS„Å´„Çà„ÇãDELETE„Éï„Ç£„É´„Çø„ÉºÂïèÈ°å„ÇíÂõûÈÅø„Åô„Çã„Åü„ÇÅ„ÄÅ„Éï„Ç£„É´„Çø„Éº„ÅØ‰ΩøÁî®„Åó„Å™„ÅÑ
            // filter: `user_id=eq.${user.id}`,
          },
          (payload) => {
            try {
              console.log('üîî Realtime event received:', {
                eventType: payload.eventType,
                schema: payload.schema,
                table: payload.table,
                new: payload.new,
                old: payload.old,
                timestamp: new Date().toISOString(),
              })

              // DELETE„Ç§„Éô„É≥„Éà„ÅÆÂá¶ÁêÜÔºàRLSÊîøÁ≠ñÂØæÂøúÔºâ
              if (payload.eventType === 'DELETE') {
                const deletedId = payload.old.id as string
                const deletedUserId = payload.old.user_id

                console.log('üóëÔ∏è Processing DELETE event:', {
                  deletedId,
                  deletedUserId,
                  currentUserId: user.id,
                })

                // user_id„ÅåÂèñÂæó„Åß„Åç„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅÁèæÂú®„ÅÆ„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ‰∏ÄË¶ß„Å´Â≠òÂú®„Åô„Çã„Åã„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                if (!deletedUserId || deletedUserId === undefined) {
                  console.log(
                    '‚ö†Ô∏è DELETE event has undefined user_id (RLS policy effect)',
                  )
                  console.log(
                    "üîç Checking if deleted bookmark exists in current user's bookmarks",
                  )

                  setAllBookmarks((prev) => {
                    const targetBookmark = prev.find((b) => b.id === deletedId)

                    if (!targetBookmark) {
                      console.log(
                        "‚ùå DELETE event for non-existent bookmark in current user's list:",
                        deletedId,
                      )
                      console.log(
                        'üîç Available bookmark IDs:',
                        prev.map((b) => b.id),
                      )
                      return prev
                    }

                    console.log(
                      "‚úÖ Found bookmark to delete in current user's list:",
                      {
                        id: targetBookmark.id,
                        title: targetBookmark.title,
                        isDeleting: (targetBookmark as any).isDeleting,
                      },
                    )

                    // Ê•ΩË¶≥ÁöÑÂâäÈô§„Å®„ÅÆÁ´∂Âêà„ÉÅ„Çß„ÉÉ„ÇØ
                    const isOptimisticallyDeleted =
                      (targetBookmark as any).isDeleting === true
                    if (isOptimisticallyDeleted) {
                      console.log(
                        'ü§ù Realtime DELETE confirms optimistic deletion:',
                        deletedId,
                      )
                    } else {
                      console.log(
                        '‚ö° Realtime DELETE from external source (extension, etc):',
                        deletedId,
                      )
                    }

                    const newBookmarks = prev.filter(
                      (bookmark) => bookmark.id !== deletedId,
                    )
                    console.log('‚úÖ Removing bookmark from state via realtime')
                    console.log(
                      'üìä Bookmarks count: before =',
                      prev.length,
                      ', after =',
                      newBookmarks.length,
                    )
                    return newBookmarks
                  })
                  return
                }

                // user_id„ÅåÂèñÂæó„Åß„Åç„ÅüÂ†¥Âêà„ÅØ„ÄÅ„É¶„Éº„Ç∂„ÉºID„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                if (deletedUserId !== user.id) {
                  console.log(
                    'üö´ Ignoring DELETE event for different user:',
                    deletedUserId,
                  )
                  return
                }

                console.log('‚úÖ DELETE event for current user, processing...')
                setAllBookmarks((prev) => {
                  const targetBookmark = prev.find((b) => b.id === deletedId)

                  if (!targetBookmark) {
                    console.log(
                      '‚ö†Ô∏è DELETE event for non-existent bookmark, already removed:',
                      deletedId,
                    )
                    return prev
                  }

                  const isOptimisticallyDeleted =
                    (targetBookmark as any).isDeleting === true
                  if (isOptimisticallyDeleted) {
                    console.log(
                      'ü§ù Realtime DELETE confirms optimistic deletion:',
                      deletedId,
                    )
                  } else {
                    console.log(
                      '‚ö° Realtime DELETE from external source:',
                      deletedId,
                    )
                  }

                  return prev.filter((bookmark) => bookmark.id !== deletedId)
                })
                return
              }

              // INSERT/UPDATE „Ç§„Éô„É≥„Éà„ÅÆË©≥Á¥∞Âá¶ÁêÜ
              if (
                payload.eventType === 'INSERT' ||
                payload.eventType === 'UPDATE'
              ) {
                const record = payload.new as any

                console.log(
                  'üîç Detailed user ID comparison for INSERT/UPDATE:',
                  {
                    eventType: payload.eventType,
                    recordUserId: record.user_id,
                    recordUserIdType: typeof record.user_id,
                    currentUserId: user.id,
                    currentUserIdType: typeof user.id,
                    isEqual: record.user_id === user.id,
                    isStrictEqual: record.user_id === user.id,
                    recordId: record.id,
                  },
                )

                // „É¶„Éº„Ç∂„ÉºIDÊú™ÂÆöÁæ©„ÅÆÂ†¥Âêà„ÅÆÂá¶ÁêÜ
                if (!record.user_id || record.user_id === undefined) {
                  console.log('‚ö†Ô∏è INSERT/UPDATE event has undefined user_id')

                  if (payload.eventType === 'INSERT') {
                    console.log(
                      'üîç Checking if this INSERT is for current user by other means',
                    )
                    // Ê•ΩË¶≥ÁöÑÊõ¥Êñ∞„Å®„ÅÆÁÖßÂêà„ÅßÂà§ÂÆö
                    setAllBookmarks((prev) => {
                      const existingTempBookmark = prev.find((b) => {
                        const isTemporary = (b as any).isLoading === true
                        const urlMatch =
                          isTemporary &&
                          (b.canonical_url === record.canonical_url ||
                            b.url === record.canonical_url ||
                            b.canonical_url === record.url ||
                            b.url === record.url)
                        return urlMatch
                      })

                      if (existingTempBookmark) {
                        console.log(
                          '‚úÖ Found matching temporary bookmark - this INSERT is for current user',
                        )
                        console.log(
                          'üîÑ Replacing temp bookmark with realtime data:',
                          {
                            tempId: existingTempBookmark.id,
                            newId: record.id,
                            url: record.canonical_url,
                          },
                        )
                        return prev.map((bookmark) =>
                          bookmark.id === existingTempBookmark.id
                            ? record
                            : bookmark,
                        )
                      }

                      console.log(
                        '‚ùå No matching temporary bookmark found - ignoring INSERT',
                      )
                      return prev
                    })
                  }
                  return
                }

                // ÈÄöÂ∏∏„ÅÆ„É¶„Éº„Ç∂„ÉºID„ÉÅ„Çß„ÉÉ„ÇØ
                if (record.user_id !== user.id) {
                  console.log(
                    'üö´ Ignoring INSERT/UPDATE event for different user:',
                    record.user_id,
                  )
                  return
                }

                console.log('‚úÖ INSERT/UPDATE event confirmed for current user')
              }

              if (payload.eventType === 'INSERT') {
                const newBookmark = payload.new as Bookmark
                console.log(
                  '‚ûï Processing INSERT event for bookmark:',
                  newBookmark.id,
                )
                setAllBookmarks((prev) => {
                  // ÊîπÂñÑ„Åï„Çå„ÅüÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ„É≠„Ç∏„ÉÉ„ÇØ
                  // 1. ID„Éô„Éº„Çπ„Åß„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØÔºà‰∏ÄÊôÇ„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÅØÈô§Â§ñÔºâ
                  const existsById = prev.some((b) => {
                    const isTemporary = (b as any).isLoading === true
                    return !isTemporary && b.id === newBookmark.id
                  })

                  if (existsById) {
                    console.log(
                      'üîç Bookmark ID already exists (non-temporary), skipping INSERT',
                    )
                    return prev
                  }

                  // 2. URL„Éô„Éº„Çπ„Åß„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØÔºàÊ•ΩË¶≥ÁöÑÊõ¥Êñ∞„Å®„ÅÆÁ´∂Âêà„ÇíÊ§úÂá∫Ôºâ
                  const existingTempBookmark = prev.find((b) => {
                    const isTemporary = (b as any).isLoading === true
                    return (
                      isTemporary &&
                      (b.canonical_url === newBookmark.canonical_url ||
                        b.url === newBookmark.canonical_url ||
                        b.canonical_url === newBookmark.url ||
                        b.url === newBookmark.url)
                    )
                  })

                  if (existingTempBookmark) {
                    console.log(
                      'üîÑ Found temporary bookmark with matching URL, replacing with realtime data:',
                      {
                        tempId: existingTempBookmark.id,
                        newId: newBookmark.id,
                        url: newBookmark.canonical_url,
                      },
                    )
                    // ‰∏ÄÊôÇ„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÇíÊ≠£Âºè„Å™„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„Å´ÁΩÆÊèõ
                    return prev.map((bookmark) =>
                      bookmark.id === existingTempBookmark.id
                        ? newBookmark
                        : bookmark,
                    )
                  }

                  console.log('‚ú® Adding new bookmark to state from realtime')
                  return [newBookmark, ...prev]
                })
              } else if (payload.eventType === 'UPDATE') {
                const updatedBookmark = payload.new as Bookmark
                console.log(
                  'üìù Processing UPDATE event for bookmark:',
                  updatedBookmark.id,
                )
                setAllBookmarks((prev) => {
                  const existingBookmark = prev.find(
                    (b) => b.id === updatedBookmark.id,
                  )

                  if (!existingBookmark) {
                    console.log(
                      '‚ö†Ô∏è UPDATE event for non-existent bookmark, ignoring:',
                      updatedBookmark.id,
                    )
                    return prev
                  }

                  // Ê•ΩË¶≥ÁöÑÊõ¥Êñ∞„Å®„ÅÆÁ´∂Âêà„ÉÅ„Çß„ÉÉ„ÇØ
                  const isOptimisticallyUpdating =
                    (existingBookmark as Bookmark & { isUpdating?: boolean })
                      .isUpdating === true
                  if (isOptimisticallyUpdating) {
                    console.log(
                      'ü§ù Realtime UPDATE confirms optimistic update:',
                      {
                        id: updatedBookmark.id,
                        title: updatedBookmark.title,
                        wasUpdating: true,
                      },
                    )
                  } else {
                    console.log(
                      '‚ö° Realtime UPDATE from external source (extension, etc):',
                      {
                        id: updatedBookmark.id,
                        title: updatedBookmark.title,
                        oldTitle: existingBookmark.title,
                        wasUpdating: false,
                      },
                    )
                  }

                  console.log('‚úÖ Applying bookmark update from realtime')
                  return prev.map((bookmark) =>
                    bookmark.id === updatedBookmark.id
                      ? updatedBookmark
                      : bookmark,
                  )
                })
              } else {
                console.warn(
                  '‚ùì Unknown realtime event type:',
                  (payload as any).eventType,
                )
              }
            } catch (error) {
              console.error(
                'üí• Error processing realtime bookmark change:',
                error,
                payload,
              )
            }
          },
        )
        .subscribe((status, err) => {
          console.log(
            `üì° Bookmark realtime subscription status: ${status} (attempt ${reconnectAttempts + 1})`,
          )

          if (status === 'SUBSCRIBED') {
            console.log(
              '‚úÖ Bookmark realtime connected successfully for channel:',
              channelName,
            )
            // Êé•Á∂öÊàêÂäüÊôÇ„ÅØÂÜçÊé•Á∂ö„Ç´„Ç¶„É≥„Çø„Éº„Çí„É™„Çª„ÉÉ„Éà
            reconnectAttempts = 0
            setError(null) // Êé•Á∂öÊàêÂäüÊôÇ„ÅØ„Ç®„É©„Éº„Çí„ÇØ„É™„Ç¢
          } else if (status === 'CHANNEL_ERROR') {
            // „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆË©≥Á¥∞„ÇíËß£Êûê„Åó„Å¶„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
            const errorMessage = err
              ? typeof err === 'string'
                ? err
                : typeof err === 'object'
                  ? JSON.stringify(err)
                  : String(err)
              : 'Unknown error'

            // ‰∏ÄËà¨ÁöÑ„Åß„Éé„Ç§„Ç∫„Å®„Å™„Çã"Unknown error"„ÅØË≠¶Âëä„É¨„Éô„É´„Åß„É≠„Ç∞
            if (errorMessage === 'Unknown error') {
              console.debug('üîï Realtime channel error (benign):', errorMessage)
            } else {
              console.warn(
                '‚ö†Ô∏è Realtime channel error (non-critical):',
                errorMessage,
              )
            }

            // CHANNEL_ERROR„Åß„ÅØÂÜçÊé•Á∂ö„Åó„Å™„ÅÑÔºàÁÑ°Èôê„É´„Éº„Éó„ÇíÈò≤„Åê„Åü„ÇÅÔºâ
            // „ÇØ„É©„Ç§„Ç¢„É≥„Éà„Çµ„Ç§„Éâ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Åå„ÅÇ„Çã„Åü„ÇÅÂü∫Êú¨Ê©üËÉΩ„ÅØÂãï‰Ωú„Åô„Çã
          } else if (status === 'TIMED_OUT') {
            console.warn('‚è∞ Bookmark realtime connection timed out')

            // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÊôÇ„ÅÆÂÜçÊé•Á∂ö„ÇíË©¶Ë°å
            if (reconnectAttempts < maxReconnectAttempts && !isUnmounted) {
              reconnectAttempts++
              console.log(
                `üîÑ Reconnecting after timeout (attempt ${reconnectAttempts}/${maxReconnectAttempts})`,
              )

              // ÁèæÂú®„ÅÆ„ÉÅ„É£„É≥„Éç„É´„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„Åó„Å¶„Åã„ÇâÂÜçÊé•Á∂ö
              const retryDelay = Math.min(1000 * 2 ** reconnectAttempts, 10000)
              reconnectTimeoutId = setTimeout(() => {
                if (!isUnmounted) {
                  // setupRealtimeÂÜÖ„Åß„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„Åï„Çå„Çã„Åü„ÇÅ„ÄÅ„Åì„Åì„Åß„ÅØ‰∏çË¶Å
                  setupRealtime()
                }
              }, retryDelay)
            } else {
              console.warn(
                '‚ö†Ô∏è Realtime connection failed after max attempts, continuing without realtime updates',
              )
            }
          } else if (status === 'CLOSED') {
            console.warn(
              'üîê Bookmark realtime connection closed for channel:',
              channelName,
            )

            // ‰∫àÊúü„Åó„Å™„ÅÑÂàáÊñ≠ÊôÇ„ÅÆÂÜçÊé•Á∂ö
            if (reconnectAttempts < maxReconnectAttempts && !isUnmounted) {
              reconnectAttempts++
              console.log(
                `üîÑ Reconnecting after unexpected closure (attempt ${reconnectAttempts}/${maxReconnectAttempts})`,
              )
              const retryDelay = Math.min(1000 * 2 ** reconnectAttempts, 10000)
              reconnectTimeoutId = setTimeout(() => {
                if (!isUnmounted) {
                  // setupRealtimeÂÜÖ„Åß„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„Åï„Çå„Çã„Åü„ÇÅ„ÄÅ„Åì„Åì„Åß„ÅØ‰∏çË¶Å
                  setupRealtime()
                }
              }, retryDelay)
            } else {
              console.warn(
                '‚ö†Ô∏è Realtime connection closed after max attempts, continuing without realtime updates',
              )
            }
          } else if (status === 'CONNECTING') {
            console.log(
              'üîÑ Connecting to bookmark realtime for channel:',
              channelName,
            )
          } else {
            console.log(
              'üìä Bookmark realtime status:',
              status,
              'for channel:',
              channelName,
            )
          }

          // „Ç®„É©„Éº„ÅÆË©≥Á¥∞„É≠„Ç∞„ÅØÈáçË¶Å„Å™Â†¥Âêà„ÅÆ„ÅøÂá∫Âäõ
          if (err && status !== 'CHANNEL_ERROR') {
            const errorMessage = err
              ? typeof err === 'string'
                ? err
                : String(err)
              : 'undefined'

            // CHANNEL_ERROR‰ª•Â§ñ„ÅÆÈáçË¶Å„Å™„Ç®„É©„Éº„ÅÆ„Åø„É≠„Ç∞Âá∫Âäõ
            if (errorMessage !== 'Unknown error') {
              console.error('üìõ Realtime error details:', {
                error: errorMessage,
                status,
                channelName,
              })
            }
          }
        })

      return () => {
        console.log(
          'üîå Unsubscribing from bookmark realtime channel:',
          channelName,
        )
        if (currentChannel === channel) {
          currentChannel = null
        }
        channel.unsubscribe()
      }
    }

    // ÂàùÂõûÊé•Á∂ö
    const initialCleanup = setupRealtime()

    // useEffectÂÖ®‰Ωì„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÈñ¢Êï∞
    return () => {
      console.log('üßπ Cleaning up bookmark realtime connection')
      isUnmounted = true

      // ‰øùÁïô‰∏≠„ÅÆÂÜçÊé•Á∂ö„Çø„Ç§„Éû„Éº„Çí„ÇØ„É™„Ç¢
      if (reconnectTimeoutId) {
        clearTimeout(reconnectTimeoutId)
        reconnectTimeoutId = null
      }

      // „ÉÅ„É£„É≥„Éç„É´„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
      initialCleanup()

      // ÁèæÂú®„ÅÆ„ÉÅ„É£„É≥„Éç„É´ÂèÇÁÖß„ÇÇ„ÇØ„É™„Ç¢
      if (currentChannel) {
        currentChannel.unsubscribe()
        currentChannel = null
      }
    }
  }, [user]) // user„ÅåÂ§â„Çè„Å£„Åü„Å®„Åç„Å´ÂÜçË®≠ÂÆö

  const createBookmark = useCallback(
    async (data: { url: string; title?: string; description?: string }) => {
      // 1. ÊúâÂäπ„Å™UUID„Åß‰∏ÄÊôÇentry„ÇíÂç≥Â∫ß„Å´‰ΩúÊàêÔºàÁúü„ÅÆÊ•ΩË¶≥ÁöÑÊõ¥Êñ∞Ôºâ
      const tempId = crypto.randomUUID() // temp-„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÇíÂâäÈô§
      const tempBookmark: Bookmark & { isLoading?: boolean } = {
        id: tempId,
        url: data.url,
        canonical_url: data.url, // ‰∏ÄÊôÇÁöÑÔºöAPI„É¨„Çπ„Éù„É≥„Çπ„ÅßÊ≠£Âºè„Å™ÂÄ§„Å´ÁΩÆÊèõ
        title: data.title || null, // „Çπ„Ç±„É´„Éà„É≥UIÁî®„ÅÆnull„Å´Â§âÊõ¥
        description: data.description || null,
        memo: null,
        thumbnail_url: null,
        is_favorite: false,
        is_pinned: false,
        pinned_at: null,
        status: 'unread',
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        user_id: '', // ‰∏ÄÊôÇÁöÑÔºöAPI„É¨„Çπ„Éù„É≥„Çπ„ÅßÊ≠£Âºè„Å™ÂÄ§„Å´ÁΩÆÊèõ
        isLoading: true, // „Çπ„Ç±„É´„Éà„É≥UIË°®Á§∫„Éï„É©„Ç∞
      }

      // 2. Âç≥Â∫ß„Å´UIÊõ¥Êñ∞ÔºàÊ•ΩË¶≥ÁöÑÊõ¥Êñ∞Ôºâ
      console.log('üöÄ Creating optimistic bookmark:', {
        tempId,
        url: data.url,
        title: data.title,
      })
      setAllBookmarks((prev) => [tempBookmark, ...prev])
      setError(null)

      try {
        // 3. APIÂëº„Å≥Âá∫„Åó
        const response = await fetch('/api/bookmarks', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data),
        })

        if (!response.ok) {
          const result = await response.json()
          throw new Error(result.error || '„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü')
        }

        const result = await response.json()
        const savedBookmark = result.data

        console.log('‚úÖ API bookmark creation successful:', {
          tempId,
          savedId: savedBookmark.id,
          url: savedBookmark.canonical_url,
        })

        // 4. temp„ÇíÊ≠£Âºè„Å™„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„Å´ÁΩÆÊèõ
        // Ê≥®ÊÑèÔºöRealtime„Ç§„Éô„É≥„Éà„ÅåÂÖà„Å´Âà∞ÁùÄ„Åô„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÅtempId„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        setAllBookmarks((prev) => {
          const tempStillExists = prev.some((b) => b.id === tempId)
          if (tempStillExists) {
            console.log('üîÑ Replacing temp bookmark with API result')
            return prev.map((bookmark) =>
              bookmark.id === tempId ? savedBookmark : bookmark,
            )
          } else {
            console.log(
              '‚ö° Temp bookmark already replaced by realtime, keeping current state',
            )
            return prev
          }
        })

        return savedBookmark
      } catch (err) {
        // 5. „Ç®„É©„ÉºÊôÇ„ÅØtemp„ÇíÂâäÈô§ÔºàrollbackÔºâ
        console.error('‚ùå Bookmark creation failed, rolling back:', err)
        setAllBookmarks((prev) =>
          prev.filter((bookmark) => bookmark.id !== tempId),
        )
        setError(
          err instanceof Error
            ? err.message
            : '„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü',
        )
        throw err
      }
    },
    [],
  )

  const updateBookmark = useCallback(
    async (id: string, updates: Partial<Bookmark>) => {
      // 1. ÁèæÂú®„ÅÆÁä∂ÊÖã„ÇírefÁµåÁî±„ÅßÂèñÂæóÔºàstale closureÂõûÈÅøÔºâ
      const previousBookmarks = bookmarksRef.current
      const targetBookmark = previousBookmarks.find((b) => b.id === id)

      if (!targetBookmark) {
        console.warn('‚ö†Ô∏è Attempting to update non-existent bookmark:', id)
        throw new Error('Êõ¥Êñ∞ÂØæË±°„ÅÆ„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì')
      }

      console.log('üìù Starting optimistic bookmark update:', {
        id,
        updates,
        currentTitle: targetBookmark.title,
        currentBookmarksCount: previousBookmarks.length,
      })

      // 2. Ê•ΩË¶≥ÁöÑÊõ¥Êñ∞ÔºöisUpdating„Éï„É©„Ç∞„Çí‰ªò„Åë„Å¶Âç≥Â∫ß„Å´„É≠„Éº„Ç´„É´Áä∂ÊÖã„ÇíÊõ¥Êñ∞
      setAllBookmarks((prev) =>
        prev.map((bookmark) =>
          bookmark.id === id
            ? ({ ...bookmark, ...updates, isUpdating: true } as Bookmark & {
                isUpdating?: boolean
              })
            : bookmark,
        ),
      )
      setError(null)

      try {
        // 3. APIÂëº„Å≥Âá∫„Åó
        console.log('üì° Sending PATCH request to API for bookmark:', id)
        const response = await fetch(`/api/bookmarks/${id}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(updates),
        })

        if (!response.ok) {
          const result = await response.json()
          throw new Error(result.error || '„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü')
        }

        const result = await response.json()
        const updatedBookmark = result.data

        console.log('‚úÖ API bookmark update successful:', {
          id,
          updatedTitle: updatedBookmark.title,
          updatedFields: Object.keys(updates),
        })

        // 4. „Çµ„Éº„Éê„Éº„Åã„Çâ„ÅÆÊ≠£Âºè„Å™ÁµêÊûú„ÅßÁä∂ÊÖã„ÇíÊõ¥Êñ∞ÔºàisUpdating„Éï„É©„Ç∞ÂâäÈô§Ôºâ
        // Ê≥®ÊÑèÔºöRealtime„Ç§„Éô„É≥„Éà„ÅåÂÖà„Å´Âà∞ÁùÄ„Åô„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÅisUpdating„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        setAllBookmarks((prev) => {
          const currentBookmark = prev.find((b) => b.id === id)
          const isStillUpdating =
            currentBookmark &&
            (currentBookmark as Bookmark & { isUpdating?: boolean })
              .isUpdating === true

          if (isStillUpdating) {
            console.log('üîÑ Replacing optimistic update with API result')
            return prev.map((bookmark) =>
              bookmark.id === id ? updatedBookmark : bookmark,
            )
          } else {
            console.log(
              '‚ö° Optimistic update already replaced by realtime, keeping current state',
            )
            return prev
          }
        })

        console.log('‚è≥ Waiting for Realtime UPDATE event to confirm update...')

        // Êõ¥Êñ∞Á¢∫Ë™ç„ÅÆ„Çø„Ç§„É†„Ç¢„Ç¶„Éà„ÇíË®≠ÂÆöÔºà5ÁßíÔºâ
        setTimeout(() => {
          const currentBookmarks = bookmarksRef.current
          const currentBookmark = currentBookmarks.find((b) => b.id === id)
          const isStillUpdating =
            currentBookmark &&
            (currentBookmark as Bookmark & { isUpdating?: boolean })
              .isUpdating === true

          if (isStillUpdating) {
            console.warn(
              '‚ö†Ô∏è Realtime UPDATE event not received after 5 seconds, forcing local update',
            )
            setAllBookmarks((prev) =>
              prev.map((bookmark) =>
                bookmark.id === id ? updatedBookmark : bookmark,
              ),
            )
          }
        }, 5000)

        return updatedBookmark
      } catch (err) {
        // 5. „Ç®„É©„ÉºÊôÇ„ÅØÂÆåÂÖ®Âæ©Êóß
        console.error('‚ùå Bookmark update failed, rolling back:', {
          id,
          error: err,
          updates,
        })

        // Realtime„ÅßÊó¢„Å´Êõ¥Êñ∞„Åï„Çå„Å¶„ÅÑ„ÇãÂèØËÉΩÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        const currentBookmarks = bookmarksRef.current
        const currentBookmark = currentBookmarks.find((b) => b.id === id)
        const isStillUpdating =
          currentBookmark &&
          (currentBookmark as Bookmark & { isUpdating?: boolean })
            .isUpdating === true

        if (!isStillUpdating) {
          console.log(
            '‚ö° Bookmark already updated by realtime, not rolling back',
          )
          // Realtime„ÅßÊó¢„Å´Êõ¥Êñ∞Ê∏à„Åø„ÅÆÂ†¥Âêà„ÅØ„ÄÅ„Ç®„É©„Éº„ÇíË®òÈå≤„Åô„Çã„ÅåÂæ©Êóß„Åó„Å™„ÅÑ
          console.warn(
            'üìä Concurrent update detected - API failed but realtime succeeded',
          )
        } else {
          console.log(
            'üîÑ Rolling back optimistic update (removing isUpdating flag)',
          )
          // isUpdating„Éï„É©„Ç∞„ÇíÂâäÈô§„Åó„Å¶ÂÖÉ„ÅÆÁä∂ÊÖã„Å´Êàª„Åô
          setAllBookmarks((prev) =>
            prev.map((bookmark) =>
              bookmark.id === id
                ? { ...targetBookmark } // ÂÖÉ„ÅÆ„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„Å´Âæ©Êóß
                : bookmark,
            ),
          )
        }

        const errorMessage =
          err instanceof Error
            ? err.message
            : '„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'
        setError(errorMessage)
        throw new Error(errorMessage)
      }
    },
    [],
  )

  const deleteBookmark = useCallback(async (id: string) => {
    // 1. ÁèæÂú®„ÅÆÁä∂ÊÖã„ÇírefÁµåÁî±„ÅßÂèñÂæóÔºàstale closureÂõûÈÅøÔºâ
    const previousBookmarks = bookmarksRef.current
    const targetBookmark = previousBookmarks.find((b) => b.id === id)

    if (!targetBookmark) {
      console.warn('‚ö†Ô∏è Attempting to delete non-existent bookmark:', id)
      throw new Error('ÂâäÈô§ÂØæË±°„ÅÆ„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì')
    }

    console.log('üóëÔ∏è Starting optimistic bookmark deletion:', {
      id,
      title: targetBookmark.title,
      url: targetBookmark.canonical_url || targetBookmark.url,
      currentBookmarksCount: previousBookmarks.length,
    })

    // 2. Ê•ΩË¶≥ÁöÑÂâäÈô§ÔºöisDeleteing„Éï„É©„Ç∞„Çí‰ªò„Åë„Çã„Å†„Åë„ÅßÂÆüÈöõ„ÅÆÂâäÈô§„ÅØRealtime„ÅßË°å„ÅÜ
    setAllBookmarks((prev) => {
      const updated = prev.map((bookmark) =>
        bookmark.id === id
          ? ({ ...bookmark, isDeleting: true } as Bookmark & {
              isDeleting?: boolean
            })
          : bookmark,
      )
      console.log('üè∑Ô∏è Added isDeleting flag to bookmark:', id)
      return updated
    })
    setError(null)

    try {
      // 3. APIÂëº„Å≥Âá∫„Åó
      console.log('üì° Sending DELETE request to API for bookmark:', id)
      const response = await fetch(`/api/bookmarks/${id}`, {
        method: 'DELETE',
      })

      if (!response.ok) {
        const result = await response.json()
        throw new Error(result.error || '„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü')
      }

      console.log('‚úÖ API bookmark deletion successful:', id)
      console.log('‚è≥ Waiting for Realtime DELETE event to confirm deletion...')

      // ÂâäÈô§Á¢∫Ë™ç„ÅÆ„Çø„Ç§„É†„Ç¢„Ç¶„Éà„ÇíË®≠ÂÆöÔºà5Áßí„Å´Êàª„ÅôÔºâ
      setTimeout(() => {
        const currentBookmarks = bookmarksRef.current
        const stillExists = currentBookmarks.some((b) => b.id === id)
        if (stillExists) {
          console.warn(
            '‚ö†Ô∏è Realtime DELETE event not received after 5 seconds, forcing local deletion',
          )
          setAllBookmarks((prev) =>
            prev.filter((bookmark) => bookmark.id !== id),
          )
        }
      }, 5000)
    } catch (err) {
      // 4. „Ç®„É©„ÉºÊôÇ„ÅØÂÆåÂÖ®Âæ©Êóß
      console.error('‚ùå Bookmark deletion failed, rolling back:', {
        id,
        error: err,
      })

      // Realtime„ÅßÊó¢„Å´ÂâäÈô§„Åï„Çå„Å¶„ÅÑ„ÇãÂèØËÉΩÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ
      const currentBookmarks = bookmarksRef.current
      const stillExists = currentBookmarks.some((b) => b.id === id)

      if (!stillExists) {
        console.log('‚ö° Bookmark already deleted by realtime, not rolling back')
        // Realtime„ÅßÊó¢„Å´ÂâäÈô§Ê∏à„Åø„ÅÆÂ†¥Âêà„ÅØ„ÄÅ„Ç®„É©„Éº„ÇíË®òÈå≤„Åô„Çã„ÅåÂæ©Êóß„Åó„Å™„ÅÑ
        console.warn(
          'üìä Concurrent deletion detected - API failed but realtime succeeded',
        )
      } else {
        console.log(
          'üîÑ Rolling back optimistic deletion (removing isDeleting flag)',
        )
        // isDeleteing„Éï„É©„Ç∞„ÇíÂâäÈô§„Åó„Å¶ÂÖÉ„ÅÆÁä∂ÊÖã„Å´Êàª„Åô
        setAllBookmarks((prev) =>
          prev.map((bookmark) =>
            bookmark.id === id
              ? { ...targetBookmark } // ÂÖÉ„ÅÆ„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„Å´Âæ©Êóß
              : bookmark,
          ),
        )
      }

      const errorMessage =
        err instanceof Error ? err.message : '„Éñ„ÉÉ„ÇØ„Éû„Éº„ÇØ„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'
      setError(errorMessage)
      throw new Error(errorMessage)
    }
  }, [])

  return {
    bookmarks,
    allBookmarks,
    loading,
    error,
    createBookmark,
    updateBookmark,
    deleteBookmark,
    refetch: fetchAllBookmarks, // ÊâãÂãï„É™„Éï„É¨„ÉÉ„Ç∑„É•„ÅåÂøÖË¶Å„Å™Â†¥Âêà
  }
}
